# 1. 시간 복잡도

## 제한 시간
대부분의 알고리즘 문제는 제한 시간이 1초 입니다.  
컴퓨터는 일반적으로 1초 동안 1억번 탐색할 수 있습니다. 

일반적으로 반복문을 한 번 순회하면 10ms가 걸립니다.  
따라서 삼중 반복문을 쓰면 시간 초과가 나오게 됩니다.

## 시간 복잡도 비교
![시간 복잡도 그래프 비교]("./1주차/images/bigo.png")   
Big O 표기법을 고려하면 가능하면 짧은 시간 복잡도를 생각하는 것이 유리합니다.  
N에 크기에 따라 적절한 시간 복잡도를 선택하여 알고리즘을 설계합니다.

다음은 주로 많이 쓰게 되는 시간 복잡도입니다.

| N의 크기 | 최대 시간 복잡도 |   
|---|--   
11 | O(N!)
25 | O(2ⁿ)  
1,000 | O(N²)
1,000,000 | O(NlogN)

"O(N!)이나 O(2ⁿ)같은 경우는 쓸 일이 있을까?" 라는 의문을 가질 수 있지만 종종 백트래킹같이 시뮬레이션하는 문제에서는 가끔 사용하는 경우도 있습니다.  

중요한 것은 많은 문제를 풀며 N의 크기, 다른 조건 등을 보며 어떤 시간 복잡도가 적절할지 생각하는 훈련입니다.

# 2. 공간 복잡도
## 메모리 제한
공간 복잡도는 보통 문제에서 크게 신경을 쓰지 않아도 됩니다.  
일반적인 문제의 메모리 제한은 512MB입니다.
int 4byte이므로 512MB의 메모리 제한이 있다면 약 1억개의 int가 필요합니다.  

하지만 실전에서는 보통 10만개가 넘는 배열을 선언하면 거의 오류가 뜹니다.  
따라서 N이 1억개인 경우 배열을 쓰는 것이 아니라 다른 알고리즘을 생각해야 합니다.  

중요한 것은 문제 조건을 보고 효율적인 탐색 과정을 떠올리며 어떤 알고리즘이 적합할지 떠올리는 것입니다.
## integer Overflow
int 범위는 약 21억입니다. 흔히 하는 실수 중 하나가 int 범위를 넘는 수를 다룰 때 long long을 사용하지 않는 것입니다. 따라서 int 범위를 초과하는 경우 미리 long long을 사용하면 편합니다.
## 실수 연산
float은 유효 자리가 6이고, double은 유효 자리가 15입니다. 문제에 오차 허용 범위 조건이 있을 경우 float, double 중 알맞게 선택해서 쓰면 됩니다.